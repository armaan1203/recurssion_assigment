# -*- coding: utf-8 -*-
"""Recurssion_assigment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h8hmojsFQW8tHyWwbHLPKtrlUk-EywGI
"""

def tower_of_hanoi(n, source, destination, auxiliary):
    # Base case: If only one disk, move it from source to destination.
    if n == 1:
        print(f"Move disk 1 from {source} to {destination}")
        return

    # Step 1: Move the top n-1 disks from source to auxiliary
    tower_of_hanoi(n - 1, source, auxiliary, destination)

    # Step 2: Move the nth disk from source to destination
    print(f"Move disk {n} from {source} to {destination}")

    # Step 3: Move the n-1 disks from auxiliary to destination
    tower_of_hanoi(n - 1, auxiliary, destination, source)

# Let's test the function with 3 disks
tower_of_hanoi(3, 'A', 'C', 'B')

"""Explanation of the Recursive Process
If you call tower_of_hanoi(3, 'A', 'C', 'B'), it will produce the sequence of moves required to transfer 3 disks from rod A to rod C using rod B as the auxiliary.

First Level of Recursion (3 disks): The function tries to move 2 disks from A to B (using C as auxiliary), then moves the 3rd disk from A to C, and finally moves 2 disks from B to C.

Second Level of Recursion (2 disks): To move 2 disks from A to B, it moves 1 disk from A to C, moves the 2nd disk from A to B, and then moves the 1 disk from C to B.

Base Case Reached: When moving 1 disk, it directly moves it from the source to the destination, completing the recursive chain.

"""

def min_distance_recursive(word1, word2):
    def helper(i, j):
        if i == 0:
            return j
        if j == 0:
            return i

        if word1[i - 1] == word2[j - 1]:
            return helper(i - 1, j - 1)


        insert = helper(i, j - 1)
        delete = helper(i - 1, j)
        replace = helper(i - 1, j - 1)

        return 1 + min(insert, delete, replace)

    return helper(len(word1), len(word2))

word1 = "intention"
word2 = "execution"
print("Minimum number of operations:", min_distance_recursive(word1, word2))

def max_value(arr,n):
  if n==1:
    return arr[0]
  else:
    return max(arr[n - 1], max_value(arr,n-1))

value=max_value([ 13, 1, -3, 22, 5],5)
print(f"The maximum value is :{value}")

def sum_array(arr,n):
  if n==1:
    return arr[0]
  else:
    return arr[n-1]+sum_array(arr,n-1)
value=sum_array([92, 23, 15, -20, 10],5)
print(f"The sum of the array is :{value}")

def is_armstrong(n, original=None, power=None):
    if original is None:
        original = n
        power = len(str(n))

    if n == 0:
        return original == 0

    last_digit = n % 10
    original -= last_digit ** power

    return is_armstrong(n // 10, original, power)

n = 153
if is_armstrong(n):
    print(f"{n} is an Armstrong number")
else:
    print(f"{n} is not an Armstrong number")

